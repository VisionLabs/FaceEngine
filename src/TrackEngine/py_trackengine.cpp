#include <iostream>
#include <pybind11/pybind11.h>
#include <fsdk/FaceEngine.h>
#include <pybind11/functional.h>
#include <pybind11/stl.h>
#include <pybind11/stl_bind.h>
#include <pybind11/operators.h>
#include <pybind11/numpy.h>
#include "TrackEngineAdapter.hpp"
#include "../FaceEngineAdapter.hpp"
#include "TrackEngineCallback.hpp"

namespace py = pybind11;

PyITrackEngine createPyFaceEnginePtr(const PyIFaceEngine& fsdk, const std::string& configPath) {
	return PyITrackEngine{fsdk, configPath};
}

PYBIND11_MODULE(TrackEngine, t) {
	t.def("createTrackEngine", &createPyFaceEnginePtr, py::return_value_policy::take_ownership,
		  "Create TrackEngine",
		  "Creates the TrackEngine object\n");


	py::class_<PyITrackEngine>(t, "PyITrackEngine", "Root LUNA SDK object interface\n")
			.def("createStream", &PyITrackEngine::createStream, "Create frames stream"
																"\tReturns:\n"
																"\t\t(object of type PyIStream)");

	py::class_<PyIStream>(t, "PyIStream", "Stream object created in TrackEngine\n")
			.def("pushFrame", &PyIStream::pushFrame,"Push frame to stream"
													"\tReturns:\n"
													"\t\t(bool result) true if frame was pushed successfully"
													"\t\tfalse if inner frame buffer is full and frame wasn't pushed\n")
			.def("getCallbacks", &PyIStream::getCallbacks,"Get all frames generated for current stream"
														  "\tReturns:\n"
														  "\t\t(array of type PyICallback)")
			.def("waitStream", &PyIStream::waitStream, "Blocking function. Use it when you have pushed all the frames "
											  "and you want to wail until all of them will be processed");

	py::class_<PyICallback>(t, "PyICallback", "Callback object generated by TrackEngine\n")
			.def_readonly("type", &PyICallback::type)
			.def_readonly("image", &PyICallback::image)
			.def_readonly("landmarks", &PyICallback::landmarks)
			.def_readonly("bbox", &PyICallback::bbox)
			.def_readonly("score", &PyICallback::score)
			.def_readonly("trackId", &PyICallback::trackId)
			.def_readonly("frameId", &PyICallback::frameId)
			.def_readonly("isDetection", &PyICallback::isDetection);

	py::enum_<PyICallback::CallbackType>(t, "TrackEngineCallbackType")
			.value("ctVisual", PyICallback::CallbackType::ctVisual, "Visual callbacks generated only for frames "
														   "where exists face tracks")
			.value("ctBestShot", PyICallback::CallbackType::ctBestShot, "Bestshot callbacks generated for frames where"
															   "face were detected")
			.value("ctTrackEnd", PyICallback::CallbackType::ctTrackEnd, "\t\tTrackEnd callback generated when face track\n"
																		"\t\twas finished\n"
																		"\t\t!!! NOTICE !!!\n"
																		"\t\tin callback of this type only trackId has value.\n"
																		"\t\tAll the rest fields are empty\n")
			.export_values();
}
